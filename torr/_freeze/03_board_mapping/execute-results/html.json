{
  "hash": "001ae0d408a730ed6600d50162dac3e1",
  "result": {
    "markdown": "---\ntitle: \"Board mapping\"\nauthor: \"Eric Wanjau and Ian Muchiri\"\ntoc: true\ntoc-location: left\nformat: \n  html:\n    number-sections: true\n    html-math-method: katex\n    code-tools: true\n    code-fold: false\n    code-link: true\neditor: visual\nexecute: \n  eval: true\n  warning: false\n  message: false\n---\n\n\nThis notebook illustrates how we assigned real world board coordinates (cm) to each square box on the chess board.\n\nThe approach was quite straightforward. We created a virtual board and then translated virtual coordinates to the manipulator's workspace.\n\n## Creating virtual chessboard.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(here)\nlibrary(waffle)\nlibrary(patchwork)\nlibrary(magick)\nlibrary(tidyverse)\n\n# Vector\nx <- c(A= 1, B = 1, C = 1, D = 1, E = 1, F = 1, G = 1)\ny <- c(A= 1, B = 1, C = 1, D = 1, E = 1, F = 1, G = 1)\n\n# Create checker boxes\nw1 = waffle(x, rows = 8, flip = TRUE, colors = c(\"black\", \"white\", \"black\", \"white\", \"black\", \"white\", \"black\", \"white\"), legend_pos = \"\", , size = 0.1) + \n  theme(plot.margin = margin(0, 0, 0, 0))\nw2 = waffle(y, rows = 8, flip = TRUE, colors = c(\"white\", \"black\", \"white\", \"black\", \"white\", \"black\", \"white\", \"black\"), legend_pos = \"\", size = 0.1) +\n  theme(plot.margin = margin(0, 0, 0, 0))\n\n# Make checker board\ncheckerboard <- w1 / w2 / w1 / w2 / w1 / w2 / w1 / w2\ncheckerboard\n```\n\n::: {.cell-output-display}\n![](03_board_mapping_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n\n```{.r .cell-code}\nggsave(\"images/checkerboard.png\", width = 7, height = 7)\n```\n:::\n\n\n## Convert image into a tibble\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(magick)\nimg <- image_read(\"images/checkerboard.png\") %>% \n  image_convert(type = \"grayscale\")\n# Dimensions of virtual board\ndim_x = 160 * 4\ndim_y = 160 * 4\nimg <- image_resize(img, paste(dim_x, dim_y, sep = \"x\"))\n\n\n# Create row and column identifiers\nrow_names <-  tibble(x = 1:dim_x, y = rep(LETTERS[1:8], each = dim_y/8), z = paste(x, \"_\", y, sep = \"\")) %>% pull(z)\n\ncol_names <-  tibble(x = 1:dim_x, y = rep(1:8, each = dim_x/8), z = paste(x, \"_\", y, sep = \"\")) %>% pull(z)\n\n# Create array and number rows and columns\nimg_array <- drop(as.integer(pluck(img, 1)))\nrownames(img_array) <- row_names\ncolnames(img_array) <- col_names\n\n\n# Create data frame from array and rename column\nimg_dfx <- img_array %>% \n  as_tibble() %>% \n  mutate(y = row_names) %>% \n  #rowid_to_column(var = \"y\") %>% \n  pivot_longer(!y, names_to = \"x\", values_to = \"pv\") %>% \n  mutate(pv = scales::rescale(pv, to = c(0, 1))) %>% \n  # binarize image\n  mutate(pv = case_when(\n    pv > 0.5 ~ 1,\n    TRUE ~ 0)) %>% \n  separate(y, c(\"y\", \"pl\")) %>% \n  separate(x, c(\"x\", \"pn\")) %>% \n  mutate(pos = paste(pl, pn, sep = \"\")) %>% \n  select(-c(pn, pl)) %>% \n  mutate(across(c(y, x, pv), as.numeric)) %>% \n  group_by(pos) %>% \n  mutate(centroidx = round(mean(x)), centroidy = round(mean(y))) %>% \n  ungroup()\n```\n:::\n\n\nOnly centroid locations are of importance. So we narrow down to that:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Obtain location centroids\ncentroids <- img_dfx %>% \n  ungroup() %>% \n  distinct(pos, centroidx, centroidy)\n\n# View centroids on the virtual board\ncentroids %>% \n  slice_head(n = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 x 3\n   pos   centroidx centroidy\n   <chr>     <dbl>     <dbl>\n 1 A1           40        40\n 2 A2          120        40\n 3 A3          200        40\n 4 A4          280        40\n 5 A5          360        40\n 6 A6          440        40\n 7 A7          520        40\n 8 A8          600        40\n 9 B1           40       120\n10 B2          120       120\n```\n:::\n:::\n\n\n## Mapping coordinates to xy\n\nOnce the centroid pixel coordinates were successfully extracted, the next step involved translating them to their corresponding real-world x-y coordinates in cm. This scaling from pixel values to cm values was achieved by the mapping function or simply using `scales::rescale()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Mapping function\nmap_fun <- function(value, from_low, from_high, to_low, to_high){\n  \n  mapped_val = (value - from_low) * (to_high - to_low) / (from_high - from_low) + (to_low)\n  \n  return(mapped_val)\n}\n\n\n# Map virtual board coordinates to manipulator workspace\ncentroids = centroids %>% \n    # mutate(x_mapped = map_fun(centroidx, from_low = 0, from_high = dim_x, to_low = 9, to_high = -9),\n    #        y_mapped = map_fun(centroidy, from_low = 0, from_high = 192, to_low = 11, to_high = 17)) %>% \n    \n    ## Using scales::rescale\n    mutate(x_mapped = scales::rescale(centroidx, to = c(9, -9), from = c(0, 640)),\n           y_mapped = scales::rescale(centroidy, to = c(11, 17), from = c(0, 192))) %>% \n    mutate(across(where(is.numeric), round)) %>% \n    # Rearrange board positions to match our physical chess board\n    mutate(\n      pl = rep(LETTERS[1:8], times = nrow(centroids)/8),\n      pn = rep(1:8, each = nrow(centroids)/8),\n      pos = paste(pl, pn, sep = \"\")) %>% \n    select(-c(pl, pn))\n\n# View centroids coordinates\ncentroids %>% \n  slice_head(n = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 x 5\n   pos   centroidx centroidy x_mapped y_mapped\n   <chr>     <dbl>     <dbl>    <dbl>    <dbl>\n 1 A1           40        40        8       12\n 2 B1          120        40        6       12\n 3 C1          200        40        3       12\n 4 D1          280        40        1       12\n 5 E1          360        40       -1       12\n 6 F1          440        40       -3       12\n 7 G1          520        40       -6       12\n 8 H1          600        40       -8       12\n 9 A2           40       120        8       15\n10 B2          120       120        6       15\n```\n:::\n:::\n\n\nNow let's visualize our handy work:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntheme_set(theme_void())\n\n# Create virtual board\ncentroids %>% \n  ggplot(mapping = aes(x = centroidx*2, y = centroidy*2)) +\n  geom_tile(aes(fill = str_extract(pos, \"[:alpha:]\")), color = \"white\", alpha = 0.8, size = 0.8, show.legend = FALSE) +\n  geom_text(aes(x = centroidx*2, y = centroidy*2 + 2, label = pos), color = \"black\", size = 3.5) +\n  coord_equal() +\n  #paletteer::scale_fill_paletteer_d(\"RColorBrewer::Set2\") +\n  scale_fill_manual(values = paletteer::paletteer_d(\"RColorBrewer::Set2\") %>% paste() %>% str_replace(\"#FFD92FFF\", \"#FFC000FF\"))\n```\n\n::: {.cell-output-display}\n![](03_board_mapping_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# Virtual coordinates on board\ncentroids %>% \n  ggplot(mapping = aes(x = centroidx*2, y = centroidy*2)) +\n  geom_tile(aes(fill = str_extract(pos, \"[:alpha:]\")), color = \"white\", alpha = 0.8, size = 0.8, show.legend = FALSE) +\n  geom_text(aes(x = centroidx*2, y = centroidy*2 + 2, label = paste(\"(\", centroidx, \",\", centroidy, \")\", sep = \"\")), color = \"black\", size = 3.3) +\n  coord_equal() +\n  #paletteer::scale_fill_paletteer_d(\"RColorBrewer::Set2\") +\n  scale_fill_manual(values = paletteer::paletteer_d(\"RColorBrewer::Set2\") %>% paste() %>% str_replace(\"#FFD92FFF\", \"#FFC000FF\"))\n```\n\n::: {.cell-output-display}\n![](03_board_mapping_files/figure-html/unnamed-chunk-10-2.png){width=672}\n:::\n\n```{.r .cell-code}\n# Real world coordinates on board\ncentroids %>% \n  ggplot(mapping = aes(x = centroidx*2, y = centroidy*2)) +\n  geom_tile(aes(fill = str_extract(pos, \"[:alpha:]\")), color = \"white\", alpha = 0.8, size = 0.8, show.legend = FALSE) +\n  geom_text(aes(x = centroidx*2, y = centroidy*2 + 2, label = paste(\"(\", x_mapped, \",\", y_mapped, \")\", sep = \"\")), color = \"black\", size = 3.3) +\n  coord_equal() +\n  #paletteer::scale_fill_paletteer_d(\"RColorBrewer::Set2\") +\n  scale_fill_manual(values = paletteer::paletteer_d(\"RColorBrewer::Set2\") %>% paste() %>% str_replace(\"#FFD92FFF\", \"#FFC000FF\"))\n```\n\n::: {.cell-output-display}\n![](03_board_mapping_files/figure-html/unnamed-chunk-10-3.png){width=672}\n:::\n:::\n\n\nHere's an example of how we would extract the real word coordinates from the tibble:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Function to return mapped values from tibble\nget_centroid <- function(position){\n  x = centroids %>% \n    filter(str_detect(pos, position)) %>% \n    pull(x_mapped)\n  \n  y = centroids %>% \n    filter(str_detect(pos, position)) %>% \n    pull(y_mapped)\n  \n  return(c(x, y))\n}\n\n# Define initial and final positions\ninitial_pos <- \"B2\"\nfinal_pos <- \"G2\"\nget_centroid(position = initial_pos)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  6 15\n```\n:::\n\n```{.r .cell-code}\nget_centroid(position = final_pos)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -6 15\n```\n:::\n:::\n\n\n## Summary\n\nThis is the approach we took at this step. We created a virtual board and then translated virtual coordinates to the manipulator's workspace.\n\nAnd with that, this section is done! Please do feel free to reach out in case of any questions, feedback and suggestions.\n\nHappy Learning,\n\n[Eric](https://twitter.com/ericntay).\n",
    "supporting": [
      "03_board_mapping_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}