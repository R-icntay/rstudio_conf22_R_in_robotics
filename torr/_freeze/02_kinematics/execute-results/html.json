{
  "hash": "69b18f8f0934edc9cb84d7289730b24a",
  "result": {
    "markdown": "---\ntitle: \"Manipulator kinematics\"\nauthor: \"Eric Wanjau and Ian Muchiri\"\ntoc: true\nnumber-sections: true\nhighlight-style: pygments\nformat:\n  html: \n    code-fold: false\n    code-tools: true\n    html-math-method: katex\n  pdf:\n    geometry: \n      - top=30mm\n      - left=30mm\n  docx: default\nexecute: \n  eval: true\n  warning: false\n  message: false\nbibliography: references.bib\n---\n\n::: {.cell}\n\n:::\n\n\nThis Notebook illustrates how the manipulator will arrive at the desired location as instructed by the speech input.\n\n## Forward and Inverse Kinematics\n\nKinematics is the science of motion that treats the subject without regard to the forces that cause it.\n\n### Forward Kinematics\n\nForward kinematics addresses the problem of computing the **position and orientation of the end effector** relative to the user's workstation given the joint angles of the manipulator.\n\nThe forward kinematics were performed in accordance with the [Denavit---Hartenberg (D-H)](https://en.wikipedia.org/wiki/Denavit%E2%80%93Hartenberg_parameters) convention. According to the D-H convention, any robot can be described kinematically by giving the values of four quantities, typically known as the D-H parameters, for each link. The link length $a$ and the link twist $\\alpha$quantities*,* describe the link itself and the remaining two; link offset $d$ and the joint angle $\\theta$ describe the link's connection to a neighboring link.\n\nTo perform the manipulator kinematics, link frames were attached to the manipulator as shown in @fig-dh. In summary, link frames are laid out as follows:\n\n1.  The $z-axis$ is in the direction of the joint axis.\n2.  The $x-axis$ is parallel to the common normal.\n3.  The $y-axis$ follows from the x-axis and z-axis by choosing it to be a right-handed coordinate system.\n\n::: {#fig-dh layout=\"[[1,1]]\"}\n![meArm parallel-link manipulator](images/MeArm3D.jpg){width=\"400\"}\n\n![DH Convention Frame assignment](images/meArm.png){width=\"400\"}\n:::\n\nOnce the link frames have been laid, the D-H parameters can be easily defined as:\n\n$d$: offset along the previous $z$ to the common normal.\n\n$\\theta$: angle about previous $z$, from old $x$ to new $x$.\n\n$a$: length of the common normal.\n\n$\\alpha$: angle about common normal from old $z\\ axis$ to new $z\\ axis$.\n\nThe D-H parameters for the meArm were evaluated as below:\n\n| Link | $\\theta$   | $a(mm)$ | $\\alpha$ | $d(mm)$ |\n|------|------------|---------|----------|---------|\n| 1    | $\\theta_1$ | 0       | 90       | 55      |\n| 2    | $\\theta_2$ | 80      | 0        | 0       |\n| 3    | $\\theta_3$ | 120     | 0        | 0       |\n\n: D-H parameters for meArm\n\nIn this convention, each homogeneous transformation $A_i$ is represented as a product of the four basic transformations [@spong2005robot], which evaluates to a $4\\times4$ matrix that is used to transform a point from frame $n$ to $n\\ -1$.\n\n\n$$\nA_i = Rot_{z, \\theta_i}\\ Trans_{x, a_i}\\ Rot_{x, \\alpha_i} \\\\\n$$\n\n$$\n= \\begin{bmatrix}\nc_{\\theta_i} & -s_{\\theta_i} & 0 & 0 \\\\\ns_{\\theta_i} & c_{\\theta_i} & 0 & 0 \\\\\n0 & 0 & 1 & 0 \\\\\n0 & 0 & 0 & 1\n\\end{bmatrix} \n\\begin{bmatrix}\n1 & 0 & 0 & 0 \\\\\n0 & 1 & 0 & 0 \\\\\n0 & 0 & 1 & d_i \\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}\\\\\n\\times \\begin{bmatrix}\n1 & 0 & 0 & a_i \\\\\n0 & 1 & 0 & 0 \\\\\n0 & 0 & 1 & 0 \\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\n1 & 0 & 0 & 0 \\\\\n0 & c_{\\alpha_i} & -s_{\\alpha_i} & 0 \\\\\n0 & s_{\\alpha_i} & c_{\\alpha_i} & 0 \\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}\n$$\n\n$$\n\\begin{bmatrix}\nc_{\\theta_i} & -s_{\\theta_i}c_{\\alpha_i} & s_{\\theta_i}c_{\\alpha_i} & a_ic_{\\theta_i} \\\\\ns_{\\theta_i} & c_{\\theta_i}c_{\\alpha_i} & -c_{\\theta_i}s_{\\alpha_i} & a_is_{\\theta_i} \\\\\n0 & s_{\\alpha_i} & c_{\\alpha_i} & d_i \\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}\n$$\n\n\nConsidering the three links of the meArm, the total homogeneous transformation will be a product of the transformations of the three links given as:\n\n\n$$\nA_T = A_1 \\times A_2 \\times A_3\n$$ {#eq-transmat}\n\n\nThe final total homogeneous transformation was derived to be:\n\n\n$$\nA_t =\\ \n\\begin{bmatrix}\ncos(\\theta_2 + \\theta_3)cos(\\theta_1) & -sin(\\theta_2 + \\theta_3)cos(\\theta_1) & sin(\\theta_1) & 4\\sigma_1cos(\\theta_1)\n\\\\cos(\\theta_2 + \\theta_3)sin(\\theta_1) & -sin(\\theta_2 + \\theta_3)sin(\\theta_1) & -cos(\\theta_1) & 4\\sigma_1sin(\\theta_1)\n \\\\\nsin(\\theta_2 + \\theta_3) & cos(\\theta_2 + \\theta_3) & 0 & 12sin(\\theta_2 + \\theta_3) + 8sin(\\theta_2) - \\frac{11}{2}\\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}\n$$ {#eq-totaltransmat}\n\n\nwhere\n\n\n$$\n\\sigma_1 = 3\\ cos(\\theta_2 + \\theta_3) + 2 \\ cos(\\theta_2)\n$$\n\n\nThe position and orientation of the end effector $x, y, z$ of the meArm was consequently obtained from the total homogeneous $A_t$transformation using the upper right 3x1 matrix as:\n\n\n$$\n\\begin{bmatrix}\nx \\\\\ny \\\\\nz\\end{bmatrix} = \n\\begin{bmatrix}\n4\\cos(\\theta_1) \\ (3\\ cos(\\theta_2 + \\theta_3) + 2 \\ cos(\\theta_2)) \\\\\n4\\sin(\\theta_1) \\ (3\\ cos(\\theta_2 + \\theta_3) + 2 \\ cos(\\theta_2)) \\\\\n12sin(\\theta_2 + \\theta_3) + 8sin(\\theta_2) - \\frac{11}{2}\n\\end{bmatrix}\n$$ {#eq-fkin}\n\n\n::: callout-tip\nSee [this paper](https://github.com/R-icntay/research-papers/blob/main/papers/ENHANCING%20PALLETIZING%20AND%20SHAPE%20DRAWING%20USING%20IMAGE%20PROCESSING%20ON%20PARALLEL%20AND%20SERIAL%20LINK%20MANIPULATORS(v7-Final).pdf) for a thorough derivation of the above.\n:::\n\nThat said, let's put this into code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Function that calculates forward kinematics\nfkin <- function(motor_angles){\n  \n  # Convert to radians\n  angles = motor_angles * pi/180\n  \n  # Extract angles\n  theta1 = angles[1] \n  theta2 = angles[2]\n  theta3 = pi - angles[3]\n  \n  # Calculate x, y, z\n  x <- 4 * cos(theta1) *( (3*cos(theta2 + theta3)) + (2*cos(theta2)))\n  \n  y <- 4 * sin(theta1) *( (3*cos(theta2 + theta3)) + (2*cos(theta2)))\n  \n  z <- (12 * sin(theta2 + theta3)) + (8*sin(theta2)) - (11/2)\n  \n  \n  # Return a tibble\n  fkin <- tibble(\n    \n    orientation = c(\"x\", \"y\", \"z\"),\n    \n    # Multiply by -1 to re-orient y and z\n    # mistake made during finding DH\n    \n    position = round(c(x, y * -1, z * -1))\n    \n  )\n  \n  return(fkin)\n  \n  \n  \n\n}\n```\n:::\n\n\nWhat would be the $x, y, z$ coordinates of the end effector when rotation of motors $1, 2, 3$ are $90, 113, 78$ degrees respectively?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate forward kinematics\nfkin(motor_angles = c(90, 113, 78))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 x 2\n  orientation position\n  <chr>          <dbl>\n1 x                  0\n2 y                 13\n3 z                  5\n```\n:::\n\n```{.r .cell-code}\nfkin(motor_angles =c(42, 110, 114))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 x 2\n  orientation position\n  <chr>          <dbl>\n1 x                -11\n2 y                 10\n3 z                 -3\n```\n:::\n:::\n\n\n### Inverse kinematics\n\nInverse kinematics addresses the more difficult converse problem of computing the **set of joint angles** that will place the end effector at a desired position and orientation. It is the computation of the manipulator joint angles given the position and orientation of the end effector.\n\nIn solving the inverse kinematics problem, the Geometric approach was used to decompose the spatial geometry into several plane-geometry problems based on the sine and the cosine rules. This was done by considering the trigonometric decomposition of various planes of the manipulator as graphically illustrated below:\n\n::: {layout=\"[[1,1]]\"}\n![](images/base_rotation.png)\n\n![](images/2nd_3rd.png){width=\"446\" height=\"396\"}\n:::\n\n\n$$\n\\theta_1 = tan^{-1} \\frac{y}{x}\n$$ {#eq-theta1}\n\n\nWith the hypotenuse r, connecting x and y obtained using the Pythagoras theorem as\n\n\n$$\nr = \\sqrt{x^2 + y^2}\n$$\n\n\nThe angles $\\theta_2$ ùëéùëõùëë $\\theta_3$ were obtained by considering the plane formed by the second and third links as illustrated:\n\n\n$$\n\\theta_2 = \\alpha + \\beta \\\\\n\\theta_2 = tan^{-1} \\frac{s}{r} \\ + tan^{-1} \\frac{l_3sin(\\theta_3)}{l_2 + l_3cos(\\theta_3)}\n$$ {#eq-theta2}\n\n$$\n\\theta_3 = cos^{-1}\\frac{x^2 + y^2 +s ^2 - l_2^2 - l_3^2}{2l_2l_3}\n$$ {#eq-theta3}\n\n\nWhere s is the difference between the distance of the end effector from the base and the offset: $$\ns = z- d\n\n$$\n\nAgain, let's put the above into code\n\n::: {.cell}\n\n```{.r .cell-code}\nikin <- function(xyz_coordinates){\n  \n  # Extract xyz coordinates\n  x = xyz_coordinates[1]\n  y = xyz_coordinates[2]\n  z = xyz_coordinates[3]\n  \n  # Account for manipulator moving right or left\n  if (x >= 0){\n    theta1 = atan(x/y) + pi/2\n  } else {\n    theta1 = atan(y/x) %>% abs()\n  }\n  \n  # Calculate theta 3 since its needed in theta 2\n  theta3 = acos((x^2 + y^2 + (z-5)^2 - 8^2 - 12^2) / (2*8*12))\n    # 8 and 12 are the dimensions of manipulator arms\n  \n  \n  # Calculate theta 2\n  theta2 = atan((5.5 - z) / (sqrt(x^2 + y^2)) ) + atan((12 * sin(theta3)) / (8 + 12*cos(theta3)))\n  \n  if(theta2 > 0){\n    theta2 = pi - abs(theta2)\n  }\n  \n  tbl <- tibble(\n    ef_position = c(x, y, z),\n    motor_angles = (c(theta1, theta2, pi-theta3)*180/pi) %>% round()\n  )\n  \n  return(tbl)\n  \n}\n```\n:::\n\nTheoretically, the results from inverse kinematics and forward kinematics should be in tandem for a given set of inputs. Let's see whether we can get our previous joint angles from the results of the forward kinematics.\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calculate inverse kinematics\nikin(xyz_coordinates = c(0, 13, 5))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 x 2\n  ef_position motor_angles\n        <dbl>        <dbl>\n1           0           90\n2          13          113\n3           5           78\n```\n:::\n\n```{.r .cell-code}\nikin(xyz_coordinates = c(-11, 10, -3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 x 2\n  ef_position motor_angles\n        <dbl>        <dbl>\n1         -11           42\n2          10          110\n3          -3          114\n```\n:::\n:::\n\n## Summary\n\nFrom the above examples, the xyz coordinate values obtained from forward kinematics operation produced the same input angles when passed through the inverse kinematics equations. This will be essential for future operations such as validating whether motor angle rotations result in a desired xyz position of the end effector.\n\nAnd with that, this section is done! Please do feel free to reach out in case of any questions, feedback and suggestions.\n\nHappy LeaRning,\n\n[Eric](https://twitter.com/ericntay).\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}